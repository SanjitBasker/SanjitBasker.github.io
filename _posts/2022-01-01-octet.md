---
layout: post
title: OCTET
date: 2022-01-01 08:00:00
description: creating a text editor in OCaml
_styles: >
  img.center {
    display: block;
    margin: 0 auto;
    border: 1px solid #FFFFFF
  }
  div.caption {
   margin-left: auto;
   margin-right: auto;
   width: 500px;
  }
---

## Highlights
- I learned a functional programming language, OCaml üê™
- I worked in a group of 3 to create Octet, an Emacs-like text editor ‚öõÔ∏è
- I designed the interface for and implemented a text buffer üìÅ

<br>
<br>

## Basics of OCaml

Unlike most programming languages, OCaml is functional: this means that rather than changing the state of variables (or even "objects") throughout a program, each name (like a variable `x`) is only assigned to once. The main abstraction provided by functional languages is that of first-class functions: "first-class" here means that these functions can be stored into variables just like integers and booleans.

Here's a simple program written in OCaml that implements insertion sort.
```ocaml
(* taken from CS 3110, spring 2022 *)
let rec isort =
  (* insert [x] into its correct position in [lst] and return the result *)
  let rec insert x lst =
    match lst with
    | [] -> [ x ]
    | h :: t -> if x <= h then x :: h :: t else h :: insert x t
  in
  (* to sort a list, sort all but the first element and then insert the first element 
     where it belongs
     more concisely, "insert head into sorted tail" *)
  function
  | [] -> []
  | h :: t -> insert h (isort t)
```

The above program is fairly easy to understand and reason about (once one gains familiarity with the syntax), but the runtime is quite slow for large lists: this is because in the worst case, the inner function `insert` takes stack space proportional to the size of its input, and so does `isort` itself. In an average-case input, the minimum element will be about halfway down the list. Regardless, the number of call-frame initializations performed in this implementation is $$O(n^2)$$, which is an expensive price to pay for "readable" code.

A compiler could rewrite this function in [continuation-passing style](https://en.wikipedia.org/wiki/Continuation-passing_style) (which uses constant stack space), by adding an extra argument `cont`, which is a function representing the remainder of the computation:

```ocaml
let isort_cp lst =
  let insert_cp lst x =
    let rec aux cont x lst =
      match lst with
      | [] -> cont [ x ]
      | h :: t ->
          if x <= h then cont (x :: lst)
          else aux (fun l -> cont (h :: l)) x t
    in
    aux (fun x -> x) x lst
  in
  let rec aux cont lst =
    match lst with
    | [] -> cont []
    | h :: t -> aux (fun l -> cont (insert_cp l h)) t
  in
  aux (fun x -> x) lst
```

As it turns out, storing an entire function is not necessary in this case and we can get by with `pred`, which is just the portion of the list we've traversed. And instead of "inserting head into sorted tail," we can just insert the elements from the original list one by one, into an accumulator initialized as the empty list `[]`.

```ocaml
(* written by me *)
let isort_tr lst =
  let insert_tr lst x =
    let rec aux pred x = function
      | [] -> List.rev_append pred [ x ]
      | h :: t ->
          if x <= h then List.rev_append (x :: pred) (h :: t)
          else aux (h :: pred) x t
    in
    aux [] x lst
  in
  List.fold_left insert_tr [] lst
```

The library functions [`List.fold_left`](https://v2.ocaml.org/api/List.html#VALfold_left) and [`List.rev_append`](https://v2.ocaml.org/api/List.html#VALrev_append) are themselves tail-recursive, meaning that this entire function uses constant stack space!

The optimization is important if the lists we're working with are long. The [`List`](https://v2.ocaml.org/api/List.html) documentation says it makes a difference when the length is around 10000. Indeed, on my machine `isort` has a noticeable delay for a reverse-sorted input of size 5000 while `isort_tr` is fast even for 20000 elements.

<br>

## Project Proposal and Philosophy

As a final project for this class, my group decided to implement a text editor with keybindings similar to Emacs. We decided to interface with [`Notty`](https://github.com/pqwy/notty), a package for displaying text to the terminal. We also researched options for autoformatting and syntax-highlighting code and decided to use [`ocaml-lsp`](https://github.com/ocaml/ocaml-lsp).

In this project, we prioritized building end-to-end. We decided (somewhat ambitiously) that our first milestone would be a bare-bones text editor with all our dependencies set up, and that for the second and third sprint we'd work on the backend and frontend in parallel while maintaining the interface from the prototype. This structure is described in *Pragmatic Programmer* as a "tracer bullet."

<br>

## Project Management and Accountability

Since I was working in a group of 3, it was important for us to keep each other accountable. We reported to each other weekly and had three progress update meetings with our "project manager," a CS 3110 TA.

<img src="/assets/img/octet-images/scope2.png" alt="drawing" width="500" class="center"/>

<div class="caption">Here's a screenshot from our second progress report. We delivered on most of what was planned and delayed searching file contents to our third sprint.</div>

<br>

## Buffer Implementation

My task was to implement the buffer which allowed for modifications to the text. The buffer implementation is nontrivial because inserting or removing a character from a string is not an $$O(1)$$ operation. However, based on the expected usage (for example, writing a long paragraph the same point in the text editor vs. lightly editing words throughout a file) the performance of an "optimal" buffer implementation can vary.

Our first buffer was just a list of strings, which had very poor asymptotic performance but was fine for small text files. We used this in our first milestone and made it a priority to rewrite as part of the second sprint.

The key insight we had in improving the buffer is that the user must first *move* the cursor to the location where the text is being inserted. While our prior implementations simply stored the cursor location as a pair of integers and updated that field. In our later implementations, we actually updated the backend's representation of the current line every time the cursor was moved. Technically, this worsened our latency, but it majorly improved our throughput on workloads consisting of lightly editing various parts of a line.

The one aspect of our runtime which we were not able to effectively amortize was memory allocation: when the buffer ran out of space, we had to allocate a larger one and copy over characters. Because our text editor is single-threaded, this latency cannot be masked to the user and the inputs may lag. However, by setting a large resize factor, we ensure that this situation occurs very rarely, and only when the buffer is growing for the first time.

In testing my buffer, I kept around the old implementations and tested extensively with OUnit. I wrote glass-box and random tests and compared the behavior of each implementation to ensure that it matched the implementation backed by a list of strings (which was straightforward enough that we could treat it like a specification).

<img src="/assets/img/octet-images/screenshot.png" alt="drawing" width="500" class="center"/>

<div class="caption">Here's our text editor in action. Syntax highlighting is enabled for OCaml, and some text is highlighted and copied to the clipboard.</div>



<br>

## Lessons Learned

While our goal in building an end-to-end prototype in the first sprint was ambitious, I think that it was effective because it forced us to (1) plan out the interfaces we'd use and (2) gave us space to work on things in parallel in the following sprints.
